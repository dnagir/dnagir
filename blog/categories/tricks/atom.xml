<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: tricks | My Octopress Blog]]></title>
  <link href="http://dnagir.github.com/dnagir/blog/categories/tricks/atom.xml" rel="self"/>
  <link href="http://dnagir.github.com/dnagir/"/>
  <updated>2012-02-08T21:14:29+11:00</updated>
  <id>http://dnagir.github.com/dnagir/</id>
  <author>
    <name><![CDATA[Your Name]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[ASP.NET MVC RenderPartial with null Model]]></title>
    <link href="http://dnagir.github.com/dnagir/blog/2009/05/06/aspnet-mvc-renderpartial-with-null/"/>
    <updated>2009-05-06T12:02:00+10:00</updated>
    <id>http://dnagir.github.com/dnagir/blog/2009/05/06/aspnet-mvc-renderpartial-with-null</id>
    <content type="html"><![CDATA[<div class='post'>
If you’ll try to pass null to the RenderPartial method it will actually pull the model from the page and will, most likely, give an error.<br />
So instead of <br />
<pre class="csharpcode">RenderPartial(“MyPartial”, item)</pre>
<style type="text/css">
.csharpcode, .csharpcode pre
{
 font-size: small;
 color: black;
 font-family: consolas, "Courier New", courier, monospace;
 background-color: #ffffff;
 /*white-space: pre;*/
}
.csharpcode pre { margin: 0em; }
.csharpcode .rem { color: #008000; }
.csharpcode .kwrd { color: #0000ff; }
.csharpcode .str { color: #006080; }
.csharpcode .op { color: #0000c0; }
.csharpcode .preproc { color: #cc6633; }
.csharpcode .asp { background-color: #ffff00; }
.csharpcode .html { color: #800000; }
.csharpcode .attr { color: #ff0000; }
.csharpcode .alt 
{
 background-color: #f4f4f4;
 width: 100%;
 margin: 0em;
}
.csharpcode .lnum { color: #606060; }
</style>

<br />
you better write<br />
<pre class="csharpcode">RenderPartial(“MuPartial”, <span class="kwrd">new</span> ViewDataDictionary { Model = item })</pre>
<br />
Just a quick note. Thanks to this <a href="http://forums.asp.net/p/1318253/2616091.aspx#2616091" target="_blank">forum post</a>.</div>


<h2>Comments</h2>


<div class='comments'>
<div class='comment'>
<div class='author'>Dmytrii Nagirniak</div>
<div class='content'>
Thanks. Good suggestion.</div>
</div>
<div class='comment'>
<div class='author'>Tahir Hassan</div>
<div class='content'>
Hi,<br /><br />since the ViewDataDictionary also contains the ModelState which will tell you if fields are invalid etc, it is better to contruct the ViewDataDictionary passing the current ViewData in; therefore your second argument would be as follows:<br /><br />new ViewDataDictionary(ViewData) { Model = item }</div>
</div>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ASP.NET MasterPages and Url Rebasing]]></title>
    <link href="http://dnagir.github.com/dnagir/blog/2009/01/08/aspnet-masterpages-and-url-rebasing/"/>
    <updated>2009-01-08T15:36:00+11:00</updated>
    <id>http://dnagir.github.com/dnagir/blog/2009/01/08/aspnet-masterpages-and-url-rebasing</id>
    <content type="html"><![CDATA[<div class='post'>
Always learn something new. I really didn't know that.<br />
I paid some attention to my MasterPage and the link to CSS file. Here is what I noticed.<br />
<br />
The default Site.Master has this markup:<br />
<pre>&lt;head runat="server"&gt;
    &lt;meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" /&gt;
    <b>&lt;link href="../../Content/Site.css" rel="stylesheet" type="text/css" /&gt;</b>
&lt;/head&gt;</pre>
I expected the link href will always be static as it is set: <b>"../../Content/Site.css"</b><br />
It means pages like these would have the CSS:<br />
<ul>
<li>Home/One/Index.aspx </li>
<li>Home/Two/Index.aspx </li>
<li>Product/One/Edit.aspx </li>
</ul>
and I expected following ones would not have CSS because of broken link:<br />
<ul>
<li>Home/Index.aspx </li>
<li>Home/Two/Three/Index.aspx </li>
<li>Product/Category/One/Edit.aspx</li>
</ul>
but I wondered that the HREF of the link has always been generated correctly!<br />
How come? <br />
The answer is <a href="http://forums.asp.net/t/1368323.aspx#2853085" target="_blank">Url Rebasing</a> - the feature of the master pages.<br />
The runtime will try to “rebase” relative URLs it finds on <b>server-side</b> controls inside a master page and paths it finds inside of the head tag.</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Reusing Controller without inheritance]]></title>
    <link href="http://dnagir.github.com/dnagir/blog/2009/01/08/reusing-controller-without-inheritance/"/>
    <updated>2009-01-08T12:41:00+11:00</updated>
    <id>http://dnagir.github.com/dnagir/blog/2009/01/08/reusing-controller-without-inheritance</id>
    <content type="html"><![CDATA[<div class='post'>
I created couple of controllers that provide some predefined functionality. All I needed is just to inherit from them. Then I decided to move them in a separate library so I would be able to reuse it in other projects. But then I faced a problem. Controllers of my project are forced to be inherited from those ones.<br />
Thou I don't have a problem with it, I additionally want every controller to have more functionality in it. You know, we always want to have something common in all our controllers.<br />
If .NET would support <a href="http://en.wikipedia.org/wiki/Multiple_inheritance" target="_blank">multiple inheritance</a> it would not be a problem at all.<br />
So what I really need in my project is:<br />
<ol>
<li>Be able to inherit from any controller in.</li>
<li>Have additional functionality in any controller.</li>
<li>Have NO code duplicates.</li>
</ol>
<br />
Again. If we inherit - we cannot have common ADDITIONAL functionality (except the inherited one) and we'll have to duplicate all the code needed in each controller (it seems so at first glance).<br />
But it is not the case if the base controller supports extensibility. I remembered about <a href="http://www.castleproject.org/MonoRail/documentation/trunk/advanced/dynactions.html" target="_blank">IDynamicActions</a> but it's not fully what I need. I just need to add common functionality to all controllers without inheritance. DynamicActions reuse actions (which I might need soon but not for now).<br />
Then I remembered <a href="http://ayende.com/Blog/archive/2008/06/04/Review-Umbrella-project.aspx" target="_blank">Umbrella Project Review</a> and it's extension points. The idea was good enough for me and I decided to go with it, but in a simplified way.<br />
No more words. The end result is below (sample controllers):<br />
<div>
<pre style="background-color: #f4f4f4; border-style: none; color: black; font-family: consolas,'Courier New',courier,monospace; font-size: 8pt; line-height: 12pt; margin: 0em; overflow: visible; padding: 0px; width: 100%;"><span style="color: green;">// Notice CommonControllerExtension and this.Extension</span>
<span style="color: blue;">public</span> <span style="color: blue;">class</span> HomeController : AbstractBaseController&lt;CommonControllerExtension&gt; {
    <span style="color: blue;">public</span> ActionResult Index() {
        ViewData[<span style="color: #006080;">"Username"</span>] = Extension.User.Username;
        <span style="color: blue;">return</span> View();
    }
}</pre>
</div>
and other controller<br />
<div>
<pre style="background-color: #f4f4f4; border-style: none; color: black; font-family: consolas,'Courier New',courier,monospace; font-size: 8pt; line-height: 12pt; margin: 0em; overflow: visible; padding: 0px; width: 100%;"><span style="color: blue;">public</span> <span style="color: blue;">class</span> TopicController : CrudController&lt;Topic, CommonControllerExtension&gt; {
    <span style="color: blue;">protected</span> <span style="color: blue;">override</span> <span style="color: blue;">void</span> PrepareUpdateInfo(UpdateModelInfo updateInfo) {
        updateInfo.Include(<span style="color: #006080;">"Name"</span>, <span style="color: #006080;">"Content"</span>);
    }

    <span style="color: blue;">protected</span> <span style="color: blue;">override</span> IEnumerable&lt;Topic&gt; GetObjectsToList() {
        <span style="color: green;">// Note Extension.WorkSpace!</span>
        <span style="color: blue;">return</span> Extension.WorkSpace.Query().Ocl&lt;Topic&gt;(<span style="color: #006080;">"Topic.allInstances-&gt;orderBy(CreatedDate)"</span>);
    }
}</pre>
</div>
<br />
The point is that we have two completely different controllers: HomeController is inherited from the abstract one; the TopicController is inherited from the CrudController (which is in turn inherited from abstract one). What they have in common is:<br />
<ol>
<li>They explicitly or implicitly inherit from <span style="font-family: Courier New;">AbstractBaseController</span>.</li>
<li>They have the same generic parameter: <span style="font-family: Courier New;">CommonControllerExtension</span>.</li>
</ol>
The second point enables the controller to share common functionality via extension class. It can be single in the whole project or couple of them - your choice.<br />
Here the main thing <span style="font-family: Courier New;">AbstractBaseController</span><br />
<div>
<pre style="background-color: #f4f4f4; border-style: none; color: black; font-family: consolas,'Courier New',courier,monospace; font-size: 8pt; line-height: 12pt; margin: 0em; overflow: visible; padding: 0px; width: 100%;"><span style="color: blue;">public</span> <span style="color: blue;">abstract</span> <span style="color: blue;">class</span> AbstractBaseController&lt;TExtendPoint&gt; : Controller <span style="color: blue;">where</span> TExtendPoint : <span style="color: blue;">class</span>, IControllerExtensionPoint&lt;Controller&gt;, <span style="color: blue;">new</span>() {
    
    <span style="color: blue;">private</span> TExtendPoint extension;


    <span style="color: #cc6633;">#region</span> Overriden

    <span style="color: blue;">protected</span> <span style="color: blue;">override</span> <span style="color: blue;">void</span> OnActionExecuting(ActionExecutingContext filterContext) {
        <span style="color: blue;">base</span>.OnActionExecuting(filterContext);
        Extension.OnInit(filterContext);
        OnInit(filterContext);
    }
    <span style="color: blue;">protected</span> <span style="color: blue;">override</span> <span style="color: blue;">void</span> OnActionExecuted(ActionExecutedContext filterContext) {
        <span style="color: blue;">base</span>.OnActionExecuted(filterContext);
        Extension.OnBeforeRender(filterContext);
        OnBeforeRender(filterContext);
    }
    <span style="color: blue;">protected</span> <span style="color: blue;">override</span> <span style="color: blue;">void</span> OnResultExecuted(ResultExecutedContext filterContext) {
        OnEnd(filterContext);
        Extension.OnEnd(filterContext);
        <span style="color: blue;">base</span>.OnResultExecuted(filterContext);
    }

    <span style="color: #cc6633;">#endregion</span>


    
    <span style="color: blue;">public</span> TExtendPoint Extension {
        get {
            <span style="color: blue;">if</span> (extension != <span style="color: blue;">null</span>)
                <span style="color: blue;">return</span> extension;

            <span style="color: green;">// Create an instance with default constructor.</span>
            extension = <span style="color: blue;">new</span> TExtendPoint();
            extension.Controller = <span style="color: blue;">this</span>;
            <span style="color: blue;">return</span> extension;
        }
    }


    <span style="color: green;">/// &lt;summary&gt;</span>
    <span style="color: green;">/// Is called when controller is ready to be initialised with additional info.</span>
    <span style="color: green;">/// &lt;/summary&gt;</span>
    <span style="color: green;">/// &lt;param name="context"&gt;The context.&lt;/param&gt;</span>
    <span style="color: blue;">public</span> <span style="color: blue;">virtual</span> <span style="color: blue;">void</span> OnInit(ActionExecutingContext context) {
    }

    <span style="color: green;">/// &lt;summary&gt;</span>
    <span style="color: green;">/// Is called when controller done it's job and action has been executed, but before the view is rendered.</span>
    <span style="color: green;">/// &lt;/summary&gt;</span>
    <span style="color: green;">/// &lt;param name="context"&gt;The context.&lt;/param&gt;</span>
    <span style="color: blue;">public</span> <span style="color: blue;">virtual</span> <span style="color: blue;">void</span> OnBeforeRender(ActionExecutedContext context) {
    }

    <span style="color: green;">/// &lt;summary&gt;</span>
    <span style="color: green;">/// Is called when the request has been processed and the controller is ready to clean-up the resourse before it gets disposed.</span>
    <span style="color: green;">/// &lt;/summary&gt;</span>
    <span style="color: green;">/// &lt;param name="context"&gt;The context.&lt;/param&gt;</span>
    <span style="color: blue;">public</span> <span style="color: blue;">virtual</span> <span style="color: blue;">void</span> OnEnd(ResultExecutedContext context) {
    }


    <span style="color: green;">/// &lt;summary&gt;</span>
    <span style="color: green;">/// Gets or sets the head title which is ViewData["HeadTitle"]</span>
    <span style="color: green;">/// &lt;/summary&gt;</span>
    <span style="color: green;">/// &lt;value&gt;The head title.&lt;/value&gt;</span>
    <span style="color: blue;">public</span> <span style="color: blue;">string</span> HeadTitle {
        get {
            <span style="color: blue;">return</span> ViewData[<span style="color: #006080;">"HeadTitle"</span>].PropGet(o =&gt; o.ToString());
        }
        set {
            ViewData[<span style="color: #006080;">"HeadTitle"</span>] = <span style="color: blue;">value</span>;
        }
    }

}</pre>
</div>
<br />
And here is the IControllerExtensionPoint interface:<br />
<div>
<pre style="background-color: #f4f4f4; border-style: none; color: black; font-family: consolas,'Courier New',courier,monospace; font-size: 8pt; line-height: 12pt; margin: 0em; overflow: visible; padding: 0px; width: 100%;"><span style="color: green;">/// &lt;summary&gt;</span>
<span style="color: green;">/// The interface that allows to provide additional functionality to controller without inheritance.</span>
<span style="color: green;">/// The implementor must have the default constructor.</span>
<span style="color: green;">/// &lt;/summary&gt;</span>
<span style="color: green;">/// &lt;typeparam name="TController"&gt;The type of the controller.&lt;/typeparam&gt;</span>
<span style="color: blue;">public</span> <span style="color: blue;">interface</span> IControllerExtensionPoint&lt;TController&gt; <span style="color: blue;">where</span> TController: Controller {

    <span style="color: green;">/// &lt;summary&gt;</span>
    <span style="color: green;">/// Gets or sets the extending controller.</span>
    <span style="color: green;">/// The setter is automatically invoked just after the instance is created by the controller.</span>
    <span style="color: green;">/// &lt;/summary&gt;</span>
    <span style="color: green;">/// &lt;value&gt;The controller.&lt;/value&gt;</span>
    TController Controller { get; set; }


    <span style="color: green;">/// &lt;summary&gt;</span>
    <span style="color: green;">/// Is called when controller is ready to be initialised with additional info.</span>
    <span style="color: green;">/// &lt;/summary&gt;</span>
    <span style="color: green;">/// &lt;param name="context"&gt;The context.&lt;/param&gt;</span>
    <span style="color: blue;">void</span> OnInit(ActionExecutingContext context);

    <span style="color: green;">/// &lt;summary&gt;</span>
    <span style="color: green;">/// Is called when controller done it's job and action has been executed, but before the view is rendered.</span>
    <span style="color: green;">/// &lt;/summary&gt;</span>
    <span style="color: green;">/// &lt;param name="context"&gt;The context.&lt;/param&gt;</span>
    <span style="color: blue;">void</span> OnBeforeRender(ActionExecutedContext context);

    <span style="color: green;">/// &lt;summary&gt;</span>
    <span style="color: green;">/// Is called when the request has been processed and the controller is ready to clean-up the resourse before it gets disposed.</span>
    <span style="color: green;">/// &lt;/summary&gt;</span>
    <span style="color: green;">/// &lt;param name="context"&gt;The context.&lt;/param&gt;</span>
    <span style="color: blue;">void</span> OnEnd(ResultExecutedContext context);

}</pre>
</div>
Here's the sample implementation sample:<br />
<div>
<pre style="background-color: #f4f4f4; border-style: none; color: black; font-family: consolas,'Courier New',courier,monospace; font-size: 8pt; line-height: 12pt; margin: 0em; overflow: visible; padding: 0px; width: 100%;"><span style="color: blue;">public</span> <span style="color: blue;">class</span> CommonControllerExtension : IControllerExtensionPoint&lt;Controller&gt;, IEcoServiceProvider {

    <span style="color: #cc6633;">#region</span> IControllerExtensionPoint&lt;Controller&gt; Members

    <span style="color: blue;">public</span> Controller Controller { get; set; }

    <span style="color: blue;">public</span> <span style="color: blue;">void</span> OnInit(ActionExecutingContext context) {
        User = GetTheUserFromSomewhere();
    }

    <span style="color: blue;">public</span> <span style="color: blue;">void</span> OnBeforeRender(ActionExecutedContext context) { 
    }

    <span style="color: blue;">public</span> <span style="color: blue;">void</span> OnEnd(ResultExecutedContext context) {
        <span style="color: blue;">if</span> (ProviderOfWorkSpace != <span style="color: blue;">null</span>)
            ProviderOfWorkSpace.ReleaseWorkSpace();
    }

    <span style="color: #cc6633;">#endregion</span>


    <span style="color: #cc6633;">#region</span> IEcoServiceProvider Members

    <span style="color: blue;">public</span> T GetEcoService&lt;T&gt;() <span style="color: blue;">where</span> T : <span style="color: blue;">class</span> {
        <span style="color: blue;">return</span> WorkSpace.GetEcoService&lt;T&gt;();
    }

    <span style="color: blue;">public</span> <span style="color: blue;">object</span> GetEcoService(Type serviceType) {
        <span style="color: blue;">return</span> WorkSpace.GetEcoService(serviceType);
    }

    <span style="color: #cc6633;">#endregion</span>



    <span style="color: blue;">public</span> IWorkSpaceProvider ProviderOfWorkSpace {
        get;
        set;
    }

    <span style="color: blue;">public</span> IWorkSpace WorkSpace {
        get {
            <span style="color: blue;">if</span> (ProviderOfWorkSpace == <span style="color: blue;">null</span>)
                ProviderOfWorkSpace = <span style="color: blue;">new</span> DefaultWebAppWorkSpaceProvider(() =&gt;
                    <span style="color: blue;">new</span> XmlWorkSpace());
            <span style="color: blue;">return</span> ProviderOfWorkSpace.GetWorkSpace();
        }
    }

    <span style="color: blue;">public</span> TObject GetObjectFromRequest&lt;TObject&gt;(<span style="color: blue;">string</span> name) <span style="color: blue;">where</span> TObject : <span style="color: blue;">class</span>, ILoopBack {
        var vpr = Controller.ValueProvider.GetValue(name);
        <span style="color: blue;">if</span> (vpr == <span style="color: blue;">null</span>)
            <span style="color: blue;">return</span> <span style="color: blue;">null</span>;
        <span style="color: blue;">return</span> WorkSpace.GetObject&lt;TObject&gt;(vpr.AttemptedValue);
    }

    <span style="color: blue;">public</span> User User { get; set; }
}</pre>
</div>
<br />
What we really have achieved here is reusing functionality with avoiding need of no multiple inheritance. It also supports notification via OnInit, OnBeforeRender and OnEnd methods.<br />
The drawback is that each controller must be inherited (implicitly or explicitly) from <span style="font-family: Courier New;">AbstractBaseController</span>. The price I'm ready to pay because of I inherit from Controller anyway.<br />
Enjoy!</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ASP.NET MVC Request  ValueProviderResult: AttemptedValue or RawValue]]></title>
    <link href="http://dnagir.github.com/dnagir/blog/2009/01/02/aspnet-mvc-request-valueproviderresult/"/>
    <updated>2009-01-02T14:21:00+11:00</updated>
    <id>http://dnagir.github.com/dnagir/blog/2009/01/02/aspnet-mvc-request-valueproviderresult</id>
    <content type="html"><![CDATA[<div class='post'>
I want to write a small helper to obtain an object from the request. Nothing special except to note that there are <span style="font-family: Courier New;">AttemptedValue</span> and <span style="font-family: Courier New;">RawValue</span> properties of <span style="font-family: Courier New;">ValueProviderResult</span>. Which one should I use for this helper keeping in mind that an ID of an object is always a string. Let's see what these props are:<br />
<ul>
<li><span style="font-family: Courier New;">RawValue</span> - first of all this is not always a string.</li>
<br />
<ul>
<li>If it comes from RouteData it can be something else (int).</li>
<li>If it comes from <span style="font-family: Courier New;">Request.Form</span> - it may be array of something (ints).</li>
</ul>
<br />
<li><span style="font-family: Courier New;">AttemptedValue</span> - is just a RawData converted to string using (<span style="font-family: Courier New;">Convert.ToString</span> with culture info). <b>But</b> in case it is obtained from <span style="font-family: Courier New;">Request.Form</span> it is just a poor value of the posted data.</li>
</ul>
So just keep it in mind. For my purpose using <span style="font-family: Courier New;">AttemptedValue</span> looks a bit more logical, so here's the method on my controller:<br />
<div>
<pre style="background-color: #f4f4f4; border-style: none; color: black; font-family: consolas,'Courier New',courier,monospace; font-size: 8pt; line-height: 12pt; margin: 0em; overflow: visible; padding: 0px; width: 100%;">TObject GetObjectFromRequest&lt;TObject&gt;(<span style="color: blue;">string</span> name) <span style="color: blue;">where</span> TObject: <span style="color: blue;">class</span>, ILoopBack {
    var vpr = ValueProvider.GetValue(name);
    <span style="color: blue;">if</span> (vpr == <span style="color: blue;">null</span>)
        <span style="color: blue;">return</span> <span style="color: blue;">null</span>;
    <span style="color: blue;">return</span> WorkSpace.GetObject&lt;TObject&gt;(vpr.AttemptedValue);
}</pre>
</div>
<br />
Usage sample:<br />
<div>
<pre style="background-color: #f4f4f4; border-style: none; color: black; font-family: consolas,'Courier New',courier,monospace; font-size: 8pt; line-height: 12pt; margin: 0em; overflow: visible; padding: 0px; width: 100%;"><span style="color: blue;">public</span> ActionResult DoSomething(MyObject obj) {
  obj.Parent = GetObjectFromRequest&lt;MyParentObject&gt;(<span style="color: #006080;">"parent"</span>);
  <span style="color: blue;">return</span> View(); <span style="color: green;">// Or whatever</span>
}</pre>
</div></div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Use insertBefore instead of appendChild]]></title>
    <link href="http://dnagir.github.com/dnagir/blog/2008/12/16/use-insertbefore-instead-of-appendchild/"/>
    <updated>2008-12-16T12:20:00+11:00</updated>
    <id>http://dnagir.github.com/dnagir/blog/2008/12/16/use-insertbefore-instead-of-appendchild</id>
    <content type="html"><![CDATA[<div class='post'>
You can get lots of problems when using node.appendChild due to an element may not be allowed to have children. It is especially valid for WYSIWYG editors.<br />
To overcome this just use node.insertBefore which will always succeeds (it seems so at least). It is so just just because of insertBefore add a child to a parent, which already has at least one child and thus is can have children.<br />
Also keeping in mind this constraint:<br />
<div>
<pre style="background-color: #f4f4f4; border-style: none; color: black; font-family: consolas,'Courier New',courier,monospace; font-size: 8pt; line-height: 12pt; margin: 0em; overflow: visible; padding: 0px; width: 100%;">existingChild.insertBefore(newChild, <span style="color: blue;">null</span><span style="color: green;">/*Feeding FF*/</span>);
Assert.areSame(existingChild.parentNode, newChild.parentNode, <span style="color: #006080;">"children should have the same parent"</span>);
Assert.areSame(root, existingchild.parentNode, <span style="color: #006080;">"[root] should be a parent of [exitingChild]"</span>)</pre>
</div>
We can rewrite our code like:<br />
<div>
<pre style="background-color: #f4f4f4; border-style: none; color: black; font-family: consolas,'Courier New',courier,monospace; font-size: 8pt; line-height: 12pt; margin: 0em; overflow: visible; padding: 0px; width: 100%;"><span style="color: green;">/*</span>
<span style="color: green;">* root-|</span>
<span style="color: green;">*      |-&gt;existingChild-|-newChild</span>
<span style="color: green;">*/</span>

<span style="color: green;">// BEFORE:</span>
existingChild.parentNode.appendChild(newChild);

<span style="color: green;">// AFTER:</span>
existingChild.insertBefore(newChild, null);</pre>
</div>
<br />
This is especially useful when you have no idea what existingChild or root can be (as it is in WYSYWYG HTML editors) and seems to be much better and exactly what users need.</div>

]]></content>
  </entry>
  
</feed>
